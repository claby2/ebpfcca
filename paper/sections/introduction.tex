\documentclass[../main.tex]{subfiles}
\begin{document}
TCP congestion control forms a critical part of the Internet ecosystem. It is an active area of research that involves new algorithms being proposed to improve network performance \cite{CCA-BBR, CCA-FCC} and discussions about how CCAs influence fairness between users \cite{CCAStarvation, CCA-Fairness}. Hence, congestion control research is critical to the stable operation and continuous improvement of the Internet, even in a post-flow rate fairness era ~\cite{PrinciplesForCongestionManagement, Dismantling}.\\
A key part of congestion control research involves developing and experimenting with new CCAs. Traditionally, this poses two main problems:
\begin{enumerate}
    \item {\bf Development friction}: CCA implementations are often split between different datapaths. In the Linux kernel, this involves writing kernel code or modules, which presents a high barrier of entry and is prone to bugs that can crash the system.
    \item {\bf Distribution difficulties}: Pushing a new CCA upstream to the Linux kernel is difficult due to rigorous review processes and backward compatibility concerns. To see real-world adoption, a new CCA must be user-friendly and easy to adopt in the early stages. Being easy to adopt is often predicated on ensuring safety and performance guarantees.
\end{enumerate}
To accurately evaluate the impacts of a new CCA on the Internet, it requires significant real-world adoption from users around the world. As a result, any CCA wishing to see eventual large-scale adoption must first propose a relatively user-friendly way for people to adopt it in the early stages. \\
With recent advancements in the eBPF space, the possibility of leveraging eBPF as a platform for implementing CCAs has become more apparent. eBPF \cite{ebpf} can be used to write and install programs that run in the Linux kernel with certain safety guarantees. Using the \texttt{struct\_ops} API, congestion control-specific hooks can be attached to the TCP stack, allowing for the implementation of new CCAs. This approach has the potential to solve both the development friction and distribution difficulties of developing new CCAs. The eBPF verifier provides powerful guarantees to the safety of the program, protecting against large amounts of hard-to-solve bugs that may lead to kernel crashes. Furthermore, the runtime-attached nature of eBPF makes iterating and testing new versions much easier. On the adoption side, the safety guarantees provided by eBPF would greatly encourage user adoption. While users can be hesitant in installing kernel patches or modules, attaching a eBPF program can be much lower-risk and thus appealing. \\
However, running CCAs in eBPF can possibly incur extra costs due to running in the eBPF VM. By considering the performance overheads of various different ways of implementing CCAs, this paper explores the degree to which eBPF can be used as a platform for developing CCAs. In addition to CCAs directly implemented using eBPF, other means of developing CCAs quickly and safely are also tested.
\end{document}
