\documentclass[../main.tex]{subfiles}
\begin{document}
CCAs form a critical part of the Internet ecosystem. While traditional discussions about CCAs centered around ideas like fairness between users (cite flow-based fairness/tcp friendly paper here), newer research explored potentials for CCAs to improve network performance (cite BBR?) and allow the user to customize bandwidth allocated to different applications on the same machine. Research on various old and new congestion control algorithms is critical to the stable operation and continuous improvement of the Internet. \\
TCP congestion control forms a critical part of the Internet ecosystem. It is often an active area of research, with new algorithms being proposed to improve network performance (cite BBR) and discussions about how CCAs influence fairness between users (cite flow-based fairness/tcp friendly paper here). Hence, congestion control research is critical to the stable operation and continuous improvement of the Internet.\\
A key part of congestion control research involves developing and experimenting with new CCAs. Traditionally, this poses two main problems:
\begin{enumerate}
    \item {\bf Development friction}: CCA implements are often split between different datapaths. In the Linux kernel, this involves writing kernel code or modules, which presents a high barrier of entry and is prone to bugs that can crash the system.
    \item {\bf Distribution difficulties}: Pushing a new CCA upstream to the Linux kernel is difficult. To see real-world adoption, a new CCA must be user-friendly and easy to adopt in the early stages. Being easy to adopt is often predicated on ensuring safety and performance guarantees.
\end{enumerate}
To accurately evaluate the impacts of a new CCA on the Internet, it requires significant real-world adoption from users around the world. As a result, any CCA wishing to see eventual large-scale adoption must first propose a relatively user-friendly way for people to adopt it in the early stages. \\
With recent advancements in the eBPF space, the possibility of leveraging eBPF as a platform for implementing CCAs has emerged. eBPF \cite{ebpf} can be used to write and install programs that run in the Linux kernel with certain safety guarantees. Using the \texttt{struct\_ops} API, congestion control-specific hooks can be attached to the TCP stack, allowing for the implementation of new CCAs. This approach has the potential to solve both the development friction and distribution difficulties of developing new CCAs. The eBPF verifier provides powerful guarantees to the safety of the program, protecting against large amounts of hard-to-solve bugs that lead to the kernel crashing. Furthermore, the runtime-attached nature of eBPF makes iterating and testing new versions much easier. On the adoption side, the safety guarantees provided by eBPF will greatly encourage user adoption. While users can be hesitant in installing kernel patches or modules, attaching a eBPF program can be much lower-risk and appealing. \\
Despite these upsides, running CCAs in eBPF can possibly incur extra costs due to running in the eBPF VM. By instrumenting the performance overheads of various different ways of implementing CCAs, this paper explores the degree to which eBPF can be used as a platform for developing CCAs. In addition to CCAs directly implemented using eBPF, other means of developing CCAs quickly and safely are also tested.The Congestion Control Plane (CCP) (cite CCP), for example, is an idea proposed to implement CCAs in user space. Since the original CCP kernel datapath is written as a Linux kernel module, we also implemented an alternative datapath in eBPF to potentially take advantage of the safety guarantees.
\end{document}
