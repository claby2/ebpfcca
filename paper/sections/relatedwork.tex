\documentclass[../main.tex]{subfiles}
\begin{document}
In order to fully evaluate performance of eBPF-based CCAs against alternative approaches, we looked at prior research aimed at reducing CCA-development overhead. Specifically, the Congestion Control Plane was developed to be an abstraction layer where developers can experiment with new CCA ideas without worrying about the intricacies of kernel networking stacks. Most notably, CCP decoupled data gathering and CCA computation. A datapath module gathers information regarding a TCP flow and sends it to user space via various channels, such as netlink sockets and unix pipes. A user space program then listens to the provided data and sends back any updates to be made to the TCP connection state. Since the computation lives in user space, developers are shielded from the potential of introducing kernel-crashing bugs as long as the underlying CCP datapath implementation is safe. The separation of data-gathering and computation also allows for further platform/OS independence. While traditional CCAs are tightly coupled with the kernel networking stack they are developed on top of, CCP allows for the same CCA to be run on different platforms with minimal changes. A CCP-based CCA can be directly ran on a completely different host, as long as there exists an existing datapath that implements the CCP standard API. \\ 
Due to CCP's datapath-reliant nature, the performance of any CCP-based congestion control will heavily depend on the implementation of the underlying datapath, as well as the channel used to communicate between user space and kernel space. In our investigations to test the performance of CCP-based CCAs, we decided to build an alternative datapath module that is implemented as an eBPF program rather than a kernel module. In addition to providing more safety guarantees, this implementation also allows us to test how the performance of CCP-based CCAs can vary depending on the underlying datapath implementation. \\

\end{document}
